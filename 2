use std::{collections::HashMap, net::IpAddr};

pub type CheckError = ();

pub enum CheckFieldValidationError {
    IncorrectNumberOfFields,
    UnexpectedField(String),
    InvalidFieldValue,
    MissingField(String),
}

pub enum CheckMessage {
    Text(String),
    Json(String),
}

pub enum CheckStatus {
    Up,
    Degreaded,
    Down,
}

pub struct CheckResult {
    pub status: CheckStatus,
    pub message: Option<CheckMessage>,
}

#[derive(Clone)]
pub enum CheckFieldValue {
    String(String),
    Username(String),
    Password(String),
    Number(i32),
    Percentage(f32),
    Float(f32),
    Duration(f32),
    Timeout(f32),
    Port(u16),
    IPAddrk(IpAddr),
}

// TODO: Consider cleaning this up.
// Macro magic might be able to make this a tad bit cleaner?
// I really don't know, but this feels a little gross.
pub trait ExtractCheckFieldValue: Sized {
    fn extract(value: CheckFieldValue) -> Result<Self, CheckFieldValidationError>;
}

impl ExtractCheckFieldValue for String {
    fn extract(value: CheckFieldValue) -> Result<Self, CheckFieldValidationError> {
        return match value {
            CheckFieldValue::String(value) => Ok(value),
            CheckFieldValue::Username(value) => Ok(value.into()),
            CheckFieldValue::Password(value) => Ok(value.into()),
            _ => Result::Err(CheckFieldValidationError::InvalidFieldValue),
        };
    }
}

impl ExtractCheckFieldValue for i32 {
    fn extract(value: CheckFieldValue) -> Result<Self, CheckFieldValidationError> {
        return match value {
            CheckFieldValue::Number(value) => Ok(value.into()),
            _ => Result::Err(CheckFieldValidationError::InvalidFieldValue),
        };
    }
}

impl ExtractCheckFieldValue for f32 {
    fn extract(value: CheckFieldValue) -> Result<Self, CheckFieldValidationError> {
        return match value {
            CheckFieldValue::Percentage(value) => Ok(value),
            CheckFieldValue::Float(value) => Ok(value),
            CheckFieldValue::Duration(value) => Ok(value),
            CheckFieldValue::Timeout(value) => Ok(value),
        };
    }
}

impl ExtractCheckFieldValue for u16 {
    fn extract(value: CheckFieldValue) -> Result<Self, CheckFieldValidationError> {
        return match value {
            CheckFieldValue::Port(value) => Ok(value.into()),
            _ => Result::Err(CheckFieldValidationError::InvalidFieldValue),
        };
    }
}

impl ExtractCheckFieldValue for IpAddr {
    fn extract(value: CheckFieldValue) -> Result<Self, CheckFieldValidationError> {
        return match value {
            CheckFieldValue::IPAddrk(value) => Ok(value.into()),
            _ => Result::Err(CheckFieldValidationError::InvalidFieldValue),
        };
    }
}

pub struct CheckMeta {
    pub name: String,
    pub description: String,
}

#[derive(Clone)]
pub struct CheckFieldSchema {
    pub name: String,
    pub description: Option<String>,
    pub default: CheckFieldValue,
}

pub trait Check {
    fn get_check_meta() -> CheckMeta
    where
        Self: Sized;

    fn get_fields_schema() -> Vec<CheckFieldSchema>
    where
        Self: Sized;

    fn check(self) -> Result<CheckResult, CheckError>;

    fn configure(
        check_fields: HashMap<String, CheckFieldValue>,
    ) -> Result<Self, CheckFieldValidationError>
    where
        Self: Sized;

    fn get_field(
        fields: &HashMap<String, CheckFieldValue>,
        field_name: &str,
    ) -> Result<CheckFieldValue, CheckFieldValidationError>
    where
        Self: Sized,
    {
        return match fields.get(field_name) {
            Some(field_value) => Ok(field_value.clone()),
            None => Result::Err(CheckFieldValidationError::MissingField(field_name.into())),
        };
    }
}
